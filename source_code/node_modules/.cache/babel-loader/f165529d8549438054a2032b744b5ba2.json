{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent, {\n    object: node\n  }) || t.isOptionalCallExpression(parent, {\n    callee: node\n  }) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction OptionalCallExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (t.isCallExpression(parent, {\n      callee: node\n    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {\n      object: node\n    }) || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/jayanshbhartiya/Desktop/Summer 2020/pv1/node_modules/@babel/generator/lib/node/parentheses.js"],"names":["Object","defineProperty","exports","value","NullableTypeAnnotation","FunctionTypeAnnotation","UpdateExpression","ObjectExpression","DoExpression","Binary","IntersectionTypeAnnotation","UnionTypeAnnotation","TSAsExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","TSInferType","BinaryExpression","SequenceExpression","AwaitExpression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalMemberExpression","OptionalCallExpression","AssignmentExpression","LogicalExpression","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","isClassDeclaration","isClassExpression","superClass","isArrayTypeAnnotation","printStack","isUnionTypeAnnotation","isIntersectionTypeAnnotation","isTypeAnnotation","isArrowFunctionExpression","length","isMemberExpression","object","isCallExpression","callee","isNewExpression","isFirstInStatement","considerArrow","operator","isBinaryExpression","left","isUnaryLike","isAwaitExpression","isBinary","parentOp","parentPos","nodeOp","nodePos","right","isLogicalExpression","isNullableTypeAnnotation","isTSArrayType","isTSOptionalType","isTSIntersectionType","isTSUnionType","isTSRestType","isVariableDeclarator","isFor","isForStatement","isThrowStatement","isReturnStatement","isIfStatement","test","isWhileStatement","isForInStatement","isSwitchStatement","discriminant","isExpressionStatement","expression","isYieldExpression","isConditionalExpression","considerDefaultExports","isExportDeclaration","isOptionalMemberExpression","isOptionalCallExpression","isTaggedTemplateExpression","isTSTypeAssertion","isTSAsExpression","isObjectPattern","i","isExportDefaultDeclaration","declaration","body","isSequenceExpression","expressions","isConditional","isAssignmentExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent, {\n    object: node\n  }) || t.isOptionalCallExpression(parent, {\n    callee: node\n  }) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction OptionalCallExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent, printStack) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent, printStack);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (t.isCallExpression(parent, {\n      callee: node\n    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {\n      object: node\n    }) || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}